# 箭头游戏死锁分析与检测算法

## 🎯 游戏规则回顾

- 区域内存在若干不重叠的箭头
- 点击箭头朝其方向移动
- 箭头移动需要保证方向上没有其他箭头阻挡
- 移动完所有箭头则胜利

## 💀 死锁情况分析

基于箭头占据(2:1)长方形的特点，分析真正的死锁情况：

### 1. 水平相互阻挡死锁

```
[→→] [←←]  
```
两个水平箭头相对放置，互相阻挡移动路径。

### 2. 垂直相互阻挡死锁

```
[↓]
[↓]
[↑]
[↑]
```

### 3. 环形循环依赖死锁

```
最小环形（4箭头）：
[→→][↓]
[↑] [↓]
[↑][←←]  
```
四个箭头形成循环：右箭头→下箭头→左箭头→上箭头→右箭头

## 🔍 死锁检测算法

### 检测思路

基于三种死锁模式的特征，设计针对性的检测算法：

```typescript
interface ArrowConfig {
  id: number;
  position: ArrowPosition;
  direction: ArrowDirection;
}

/**
 * 检测是否存在死锁
 */
export const detectDeadlock = (
  arrows: ArrowConfig[],
  rows: number,
  cols: number
): boolean => {
  return detectHorizontalDeadlock(arrows) ||
         detectVerticalDeadlock(arrows) ||
         detectCyclicDeadlock(arrows, rows, cols);
};
```

### 1. 水平相互阻挡检测

```typescript
const detectHorizontalDeadlock = (arrows: ArrowConfig[]): boolean => {
  const horizontalArrows = arrows.filter(arrow => 
    arrow.direction === 'left' || arrow.direction === 'right'
  );
  
  for (let i = 0; i < horizontalArrows.length; i++) {
    for (let j = i + 1; j < horizontalArrows.length; j++) {
      const arrow1 = horizontalArrows[i];
      const arrow2 = horizontalArrows[j];
      
      // 检查是否在同一行且相邻
      if (arrow1.position.row === arrow2.position.row) {
        const isAdjacent = Math.abs(arrow1.position.col - arrow2.position.col) === 2;
        const isFacing = (
          (arrow1.direction === 'right' && arrow2.direction === 'left' && 
           arrow1.position.col < arrow2.position.col) ||
          (arrow1.direction === 'left' && arrow2.direction === 'right' && 
           arrow1.position.col > arrow2.position.col)
        );
        
        if (isAdjacent && isFacing) {
          return true; // 发现水平死锁
        }
      }
    }
  }
  
  return false;
};
```

### 2. 垂直相互阻挡检测

```typescript
const detectVerticalDeadlock = (arrows: ArrowConfig[]): boolean => {
  const verticalArrows = arrows.filter(arrow => 
    arrow.direction === 'up' || arrow.direction === 'down'
  );
  
  for (let i = 0; i < verticalArrows.length; i++) {
    for (let j = i + 1; j < verticalArrows.length; j++) {
      const arrow1 = verticalArrows[i];
      const arrow2 = verticalArrows[j];
      
      // 检查是否在同一列且相邻
      if (arrow1.position.col === arrow2.position.col) {
        const isAdjacent = Math.abs(arrow1.position.row - arrow2.position.row) === 2;
        const isFacing = (
          (arrow1.direction === 'down' && arrow2.direction === 'up' && 
           arrow1.position.row < arrow2.position.row) ||
          (arrow1.direction === 'up' && arrow2.direction === 'down' && 
           arrow1.position.row > arrow2.position.row)
        );
        
        if (isAdjacent && isFacing) {
          return true; // 发现垂直死锁
        }
      }
    }
  }
  
  return false;
};
```

### 3. 环形循环依赖检测

```typescript
const detectCyclicDeadlock = (
  arrows: ArrowConfig[],
  rows: number,
  cols: number
): boolean => {
  const grid = createGridFromArrows(arrows, rows, cols);
  
  // 构建依赖图
  const dependencies = new Map<number, number[]>();
  
  arrows.forEach(arrow => {
    const blockers = getBlockingArrows(arrow, arrows, grid, rows, cols);
    dependencies.set(arrow.id, blockers);
  });
  
  // 检测循环依赖
  return hasCycle(dependencies);
};

const getBlockingArrows = (
  arrow: ArrowConfig,
  allArrows: ArrowConfig[],
  grid: number[][],
  rows: number,
  cols: number
): number[] => {
  const blockers: number[] = [];
  const { position, direction } = arrow;
  
  // 根据方向获取移动路径上的阻挡箭头
  let checkPositions: ArrowPosition[] = [];
  
  switch (direction) {
    case 'up':
      for (let row = position.row - 1; row >= 0; row--) {
        checkPositions.push({ row, col: position.col });
      }
      break;
    case 'down':
      for (let row = position.row + 2; row < rows; row++) {
        checkPositions.push({ row, col: position.col });
      }
      break;
    case 'left':
      for (let col = position.col - 1; col >= 0; col--) {
        checkPositions.push({ row: position.row, col });
      }
      break;
    case 'right':
      for (let col = position.col + 2; col < cols; col++) {
        checkPositions.push({ row: position.row, col });
      }
      break;
  }
  
  // 找到第一个阻挡的箭头
  for (const pos of checkPositions) {
    if (isPositionInBounds(pos, rows, cols)) {
      const cellValue = grid[pos.row][pos.col];
      if (cellValue !== 0 && cellValue !== arrow.id) {
        blockers.push(cellValue);
        break; // 只需要第一个阻挡者
      }
    }
  }
  
  return blockers;
};

const hasCycle = (dependencies: Map<number, number[]>): boolean => {
  const visited = new Set<number>();
  const recursionStack = new Set<number>();
  
  for (const nodeId of dependencies.keys()) {
    if (hasCycleDFS(nodeId, dependencies, visited, recursionStack)) {
      return true;
    }
  }
  
  return false;
};

const hasCycleDFS = (
  nodeId: number,
  dependencies: Map<number, number[]>,
  visited: Set<number>,
  recursionStack: Set<number>
): boolean => {
  if (recursionStack.has(nodeId)) {
    return true; // 发现循环
  }
  
  if (visited.has(nodeId)) {
    return false; // 已访问过且无循环
  }
  
  visited.add(nodeId);
  recursionStack.add(nodeId);
  
  const deps = dependencies.get(nodeId) || [];
  for (const depId of deps) {
    if (hasCycleDFS(depId, dependencies, visited, recursionStack)) {
      return true;
    }
  }
  
  recursionStack.delete(nodeId);
  return false;
};
```

## ⚡ 算法优势

### 1. 精确性
- 直接检测三种已知死锁模式
- 避免通用回溯算法的性能开销

### 2. 高效性
- 时间复杂度：O(n²) 用于相互阻挡检测，O(n+e) 用于循环检测
- 空间复杂度：O(n) 用于存储依赖关系

### 3. 可扩展性
- 模块化设计，易于添加新的死锁模式
- 可与现有验证系统集成
