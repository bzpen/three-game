# ç®­å¤´æ¸¸æˆæ­»é”åˆ†æä¸æ£€æµ‹ç®—æ³•

## ğŸ¯ æ¸¸æˆè§„åˆ™å›é¡¾

- åŒºåŸŸå†…å­˜åœ¨è‹¥å¹²ä¸é‡å çš„ç®­å¤´
- ç‚¹å‡»ç®­å¤´æœå…¶æ–¹å‘ç§»åŠ¨
- ç®­å¤´ç§»åŠ¨éœ€è¦ä¿è¯æ–¹å‘ä¸Šæ²¡æœ‰å…¶ä»–ç®­å¤´é˜»æŒ¡
- ç§»åŠ¨å®Œæ‰€æœ‰ç®­å¤´åˆ™èƒœåˆ©

## ğŸ’€ æ­»é”æƒ…å†µåˆ†æ

åŸºäºç®­å¤´å æ®(2:1)é•¿æ–¹å½¢çš„ç‰¹ç‚¹ï¼Œåˆ†æçœŸæ­£çš„æ­»é”æƒ…å†µï¼š

### 1. æ°´å¹³ç›¸äº’é˜»æŒ¡æ­»é”

```
[â†’â†’] [â†â†]  
```
ä¸¤ä¸ªæ°´å¹³ç®­å¤´ç›¸å¯¹æ”¾ç½®ï¼Œäº’ç›¸é˜»æŒ¡ç§»åŠ¨è·¯å¾„ã€‚

### 2. å‚ç›´ç›¸äº’é˜»æŒ¡æ­»é”

```
[â†“]
[â†“]
[â†‘]
[â†‘]
```

### 3. ç¯å½¢å¾ªç¯ä¾èµ–æ­»é”

```
æœ€å°ç¯å½¢ï¼ˆ4ç®­å¤´ï¼‰ï¼š
[â†’â†’][â†“]
[â†‘] [â†“]
[â†‘][â†â†]  
```
å››ä¸ªç®­å¤´å½¢æˆå¾ªç¯ï¼šå³ç®­å¤´â†’ä¸‹ç®­å¤´â†’å·¦ç®­å¤´â†’ä¸Šç®­å¤´â†’å³ç®­å¤´

## ğŸ” æ­»é”æ£€æµ‹ç®—æ³•

### æ£€æµ‹æ€è·¯

åŸºäºä¸‰ç§æ­»é”æ¨¡å¼çš„ç‰¹å¾ï¼Œè®¾è®¡é’ˆå¯¹æ€§çš„æ£€æµ‹ç®—æ³•ï¼š

```typescript
interface ArrowConfig {
  id: number;
  position: ArrowPosition;
  direction: ArrowDirection;
}

/**
 * æ£€æµ‹æ˜¯å¦å­˜åœ¨æ­»é”
 */
export const detectDeadlock = (
  arrows: ArrowConfig[],
  rows: number,
  cols: number
): boolean => {
  return detectHorizontalDeadlock(arrows) ||
         detectVerticalDeadlock(arrows) ||
         detectCyclicDeadlock(arrows, rows, cols);
};
```

### 1. æ°´å¹³ç›¸äº’é˜»æŒ¡æ£€æµ‹

```typescript
const detectHorizontalDeadlock = (arrows: ArrowConfig[]): boolean => {
  const horizontalArrows = arrows.filter(arrow => 
    arrow.direction === 'left' || arrow.direction === 'right'
  );
  
  for (let i = 0; i < horizontalArrows.length; i++) {
    for (let j = i + 1; j < horizontalArrows.length; j++) {
      const arrow1 = horizontalArrows[i];
      const arrow2 = horizontalArrows[j];
      
      // æ£€æŸ¥æ˜¯å¦åœ¨åŒä¸€è¡Œä¸”ç›¸é‚»
      if (arrow1.position.row === arrow2.position.row) {
        const isAdjacent = Math.abs(arrow1.position.col - arrow2.position.col) === 2;
        const isFacing = (
          (arrow1.direction === 'right' && arrow2.direction === 'left' && 
           arrow1.position.col < arrow2.position.col) ||
          (arrow1.direction === 'left' && arrow2.direction === 'right' && 
           arrow1.position.col > arrow2.position.col)
        );
        
        if (isAdjacent && isFacing) {
          return true; // å‘ç°æ°´å¹³æ­»é”
        }
      }
    }
  }
  
  return false;
};
```

### 2. å‚ç›´ç›¸äº’é˜»æŒ¡æ£€æµ‹

```typescript
const detectVerticalDeadlock = (arrows: ArrowConfig[]): boolean => {
  const verticalArrows = arrows.filter(arrow => 
    arrow.direction === 'up' || arrow.direction === 'down'
  );
  
  for (let i = 0; i < verticalArrows.length; i++) {
    for (let j = i + 1; j < verticalArrows.length; j++) {
      const arrow1 = verticalArrows[i];
      const arrow2 = verticalArrows[j];
      
      // æ£€æŸ¥æ˜¯å¦åœ¨åŒä¸€åˆ—ä¸”ç›¸é‚»
      if (arrow1.position.col === arrow2.position.col) {
        const isAdjacent = Math.abs(arrow1.position.row - arrow2.position.row) === 2;
        const isFacing = (
          (arrow1.direction === 'down' && arrow2.direction === 'up' && 
           arrow1.position.row < arrow2.position.row) ||
          (arrow1.direction === 'up' && arrow2.direction === 'down' && 
           arrow1.position.row > arrow2.position.row)
        );
        
        if (isAdjacent && isFacing) {
          return true; // å‘ç°å‚ç›´æ­»é”
        }
      }
    }
  }
  
  return false;
};
```

### 3. ç¯å½¢å¾ªç¯ä¾èµ–æ£€æµ‹

```typescript
const detectCyclicDeadlock = (
  arrows: ArrowConfig[],
  rows: number,
  cols: number
): boolean => {
  const grid = createGridFromArrows(arrows, rows, cols);
  
  // æ„å»ºä¾èµ–å›¾
  const dependencies = new Map<number, number[]>();
  
  arrows.forEach(arrow => {
    const blockers = getBlockingArrows(arrow, arrows, grid, rows, cols);
    dependencies.set(arrow.id, blockers);
  });
  
  // æ£€æµ‹å¾ªç¯ä¾èµ–
  return hasCycle(dependencies);
};

const getBlockingArrows = (
  arrow: ArrowConfig,
  allArrows: ArrowConfig[],
  grid: number[][],
  rows: number,
  cols: number
): number[] => {
  const blockers: number[] = [];
  const { position, direction } = arrow;
  
  // æ ¹æ®æ–¹å‘è·å–ç§»åŠ¨è·¯å¾„ä¸Šçš„é˜»æŒ¡ç®­å¤´
  let checkPositions: ArrowPosition[] = [];
  
  switch (direction) {
    case 'up':
      for (let row = position.row - 1; row >= 0; row--) {
        checkPositions.push({ row, col: position.col });
      }
      break;
    case 'down':
      for (let row = position.row + 2; row < rows; row++) {
        checkPositions.push({ row, col: position.col });
      }
      break;
    case 'left':
      for (let col = position.col - 1; col >= 0; col--) {
        checkPositions.push({ row: position.row, col });
      }
      break;
    case 'right':
      for (let col = position.col + 2; col < cols; col++) {
        checkPositions.push({ row: position.row, col });
      }
      break;
  }
  
  // æ‰¾åˆ°ç¬¬ä¸€ä¸ªé˜»æŒ¡çš„ç®­å¤´
  for (const pos of checkPositions) {
    if (isPositionInBounds(pos, rows, cols)) {
      const cellValue = grid[pos.row][pos.col];
      if (cellValue !== 0 && cellValue !== arrow.id) {
        blockers.push(cellValue);
        break; // åªéœ€è¦ç¬¬ä¸€ä¸ªé˜»æŒ¡è€…
      }
    }
  }
  
  return blockers;
};

const hasCycle = (dependencies: Map<number, number[]>): boolean => {
  const visited = new Set<number>();
  const recursionStack = new Set<number>();
  
  for (const nodeId of dependencies.keys()) {
    if (hasCycleDFS(nodeId, dependencies, visited, recursionStack)) {
      return true;
    }
  }
  
  return false;
};

const hasCycleDFS = (
  nodeId: number,
  dependencies: Map<number, number[]>,
  visited: Set<number>,
  recursionStack: Set<number>
): boolean => {
  if (recursionStack.has(nodeId)) {
    return true; // å‘ç°å¾ªç¯
  }
  
  if (visited.has(nodeId)) {
    return false; // å·²è®¿é—®è¿‡ä¸”æ— å¾ªç¯
  }
  
  visited.add(nodeId);
  recursionStack.add(nodeId);
  
  const deps = dependencies.get(nodeId) || [];
  for (const depId of deps) {
    if (hasCycleDFS(depId, dependencies, visited, recursionStack)) {
      return true;
    }
  }
  
  recursionStack.delete(nodeId);
  return false;
};
```

## âš¡ ç®—æ³•ä¼˜åŠ¿

### 1. ç²¾ç¡®æ€§
- ç›´æ¥æ£€æµ‹ä¸‰ç§å·²çŸ¥æ­»é”æ¨¡å¼
- é¿å…é€šç”¨å›æº¯ç®—æ³•çš„æ€§èƒ½å¼€é”€

### 2. é«˜æ•ˆæ€§
- æ—¶é—´å¤æ‚åº¦ï¼šO(nÂ²) ç”¨äºç›¸äº’é˜»æŒ¡æ£€æµ‹ï¼ŒO(n+e) ç”¨äºå¾ªç¯æ£€æµ‹
- ç©ºé—´å¤æ‚åº¦ï¼šO(n) ç”¨äºå­˜å‚¨ä¾èµ–å…³ç³»

### 3. å¯æ‰©å±•æ€§
- æ¨¡å—åŒ–è®¾è®¡ï¼Œæ˜“äºæ·»åŠ æ–°çš„æ­»é”æ¨¡å¼
- å¯ä¸ç°æœ‰éªŒè¯ç³»ç»Ÿé›†æˆ
